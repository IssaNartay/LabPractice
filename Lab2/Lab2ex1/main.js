// Lab 2

class Node {
	// вспомогательный класс
	constructor(data, next = null) {
		// Конструктор принимает параматеры данные и следущий элемент который имеет значение Нулл по умолч.
		this.data = data // Данные
		this.next = next // Следущий элемент
	}
}
class MyLinkedList {
	//
	constructor() {
		//
		this.head = null // Первый элемент, пока список не наполнен он равен Нулл
		this.tail = null // Последний элемент, пока список не наполнен он равен Нулл
	}

	addAtTail(data) { // Добавления в конец нового элемента. Он принимает данные
		const node = new Node(data) // Узел node - это обьект
		if (this.tail) {
			// Если Последний эл. есть то тогда указываем что следущий эл. станет Нод
			this.tail.next = node // this.tail - это ссылка на прошлый, последний эл. в списке. Поэтому мы меняем его свйоство некст
		}

		if (!this.head) {
			// Если не определен Первый элемент и что список еще пуст
			this.head = node // мы присвоем первому элементу значение node
		}

		this.tail = node // В конце node должен стать последним элементом
	}

	reverseElements() {
		// Обратный порядок элементов
		let current = this.head //
		let prev = null
		let nextNode = null
		while (current) {
			// Перезаписываем данные между собой меняя порядок
			nextNode = current.next
			current.next = prev
			prev = current
			current = nextNode
		}
		this.tail = this.head // в данный момент head равен последнему элементу поэтому перезаписываем его в tail
		this.head = prev // А последний элемент перезаписываем в prev
	}

	addAtHead(data) {
		// Добавления в начало нового элемента. Он принимает данные
		const node = new Node(data, this.head) // В параметр next мы вставим первый элемент head.
		this.head = node // Так как node стал первым элеметном то нужно его присвоить в head

		if (!this.tail) {
			// Если не определен Последний элемент
			this.tail = node // Последний элемент равняется нод
		}
	}

	addAfter(after, data) {
		// Добавления после заданного элемента. Он принимает в себе два параметра. 1. Элемент после которого мы хотим добавить новый элемент. 2. Новый эл. которого мы хотим добавить.
		const found = this.find(after) // Переменная found будет равнятся методу find в которому мы передали элемент after
		if (!found) {
			// Если ничего не нашли мы можем сделать просто return и дальнейший код не будет выполняться
			return
		}

		found.next = new Node(data, found.next) // У найденного элемента мы меняем свойство на нод в котором параметре next будет найденный элемент
	}

	find(data) {
		// Найти элемент
		if (!this.head) {
			// если не определен первый элемент или список пустой
			return // просто выходим с функции или можем преписать туда ошибку
		}
		let current = this.head // Текущий эл. будет указывать на первый эл.
		while (current) {
			// Цикл будет итерировать до тех пор пока текущий элемент не будет ложной или нулл
			if (current.data === data) {
				// Если данные текущий эл. равен данным которым мы хотим найти
				return current // Возвращаем текущий эл.
			}
			current = current.next // предополения текущего элемента не следущий текущий эл. в случае если небыло найдено совпадения
		}
	}

	toArray() {
		// Данный метод приведет весь связанный список к массиву
		const output = [] // Массив которому перезапишем результат
		let current = this.head // Начинаем с начало списка
		while (current) {
			// Цикл будет итерировать до тех пор пока текущий элемент не будет ложной или нулл
			output.push(current) // добавляем в массив текущий эл.
			current = current.next // Когда закончиться цикл текущий эл. будет равен нуллу
		}
		return output // возвращаем итоговый массив
	}

	printElements() { // Вывод элементов в консоль
		let current = this.head
		let result = "" // Создаем переменую где потом запишем результаты
		while (current) {
			result += current.data + " " // Записываем итерируемые элементы ставя между ними пробелы
			current = current.next // предопределим current чтобы он равнялся к нулл
		}
		console.log(result)
	}

	deleteElements(data) {
		// Удаление заданного элемента
		if (!this.head) {
			// если не определен первый элемент или список пустой
			return // просто выходим с функции или можем преписать туда ошибку
		}

		while (this.head && this.head.data === data) {
			// Через цикл проверяем если первый эл. и данные первого элемента равен элементу который мы хотим удалить
			this.head = this.head.next // Мы меняем первый элемент на следущий
		}

		let current = this.head // Текущий эл. будет первым эл.
		while (current.next) {
			// Цикл будет итерироваться до тех пор пока current.next не будет ложной. Для последнего эл. это работать не будет.
			if (current.next.data === data) {
				// Если data в next текущего элемента равна элементу который мы хотим удалить.
				current.next = current.next.next // Мы должны убрать элемента из цепочки. То есть мы перешагиваем через один элемент.
			} else {
				// Иначе мы берем следущий элемент по списку.
				current = current.next
			}
		}
		if (this.tail.data === data) {
			// Если последний элемент равняется элементу которого мы хотим удалить
			this.tail = current // Последний элемент будет текущим. Потому что в нем содержится предпоследний элемент который уже прошел наши проверки
		}
	}
}

const list = new MyLinkedList()
list.addAtHead("Hi")
list.addAtTail("My")
list.addAtTail("name")
list.addAtTail("Issa")

list.addAfter("name", "is")
// list.reverseElements()

list.printElements()
console.log(list)
